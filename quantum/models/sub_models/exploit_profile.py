"""
╔═══════════════════════════════════════════════════════════════════════════════════════╗
║  EXPLOIT PROFILE - Faiblesses Exploitables & Marchés Optimaux                        ║
║  Version: 2.0                                                                        ║
║  "Chaque équipe a une faille. La trouver, c'est trouver la value."                   ║
╚═══════════════════════════════════════════════════════════════════════════════════════╝

Architecture Mon_PS - Chess Engine V2.0
Créé le: 2025-12-10

Installation: /home/Mon_ps/quantum/models/sub_models/exploit_profile.py

CONCEPT:
Synthèse des faiblesses exploitables détectées dans tous les DNA.
Mapping direct vers les marchés de paris avec edges calculés.
"""

from pydantic import BaseModel, Field, ConfigDict, computed_field
from typing import Optional, List, Dict
from datetime import datetime

from ..base import QuantumBaseModel, ConfidentMetric
from ..enums import MarketType, DataQuality


# ═══════════════════════════════════════════════════════════════════════════════════════
# WEAKNESS TYPES
# ═══════════════════════════════════════════════════════════════════════════════════════

class IdentifiedWeakness(BaseModel):
    """
    Faiblesse identifiée avec impact sur les marchés.
    """
    
    model_config = ConfigDict(frozen=False)
    
    weakness_type: str = Field(description="Type de faiblesse")
    severity: str = Field(
        default="MODERATE",
        description="CRITICAL, HIGH, MODERATE, LOW"
    )
    
    source: str = Field(
        default="",
        description="Source DNA (defense, context, goalkeeper, coach, variance)"
    )
    
    description: str = Field(default="")
    
    # Impact sur les marchés
    affected_markets: List[str] = Field(default_factory=list)
    edge_boost_pct: float = Field(
        default=0,
        description="Boost d'edge en % quand exploité"
    )
    
    # Confidence
    sample_size: int = Field(default=0, ge=0)
    confidence: float = Field(default=0.5, ge=0, le=1)
    
    @computed_field
    @property
    def is_actionable(self) -> bool:
        """True si la faiblesse est exploitable."""
        return self.severity in ["CRITICAL", "HIGH"] and self.confidence >= 0.5


# ═══════════════════════════════════════════════════════════════════════════════════════
# MARKET EDGE
# ═══════════════════════════════════════════════════════════════════════════════════════

class MarketEdge(BaseModel):
    """
    Edge calculé sur un marché spécifique.
    """
    
    model_config = ConfigDict(frozen=False)
    
    market: str = Field(description="Type de marché")
    
    # Edge components
    base_edge_pct: float = Field(
        default=0,
        description="Edge de base avant ajustements"
    )
    weakness_boost_pct: float = Field(
        default=0,
        description="Boost dû aux faiblesses identifiées"
    )
    variance_adjustment_pct: float = Field(
        default=0,
        description="Ajustement dû à la variance (régression)"
    )
    coach_adjustment_pct: float = Field(
        default=0,
        description="Ajustement dû au profil coach"
    )
    
    # Final
    total_edge_pct: float = Field(default=0)
    
    # Historical
    historical_hit_rate: float = Field(default=0, ge=0, le=100)
    historical_roi: float = Field(default=0)
    sample_size: int = Field(default=0, ge=0)
    
    # Confidence
    confidence: float = Field(default=0.5, ge=0, le=1)
    
    @computed_field
    @property
    def edge_tier(self) -> str:
        """Classification de l'edge."""
        edge = self.total_edge_pct
        conf = self.confidence
        
        if edge >= 10 and conf >= 0.7:
            return "ELITE"
        elif edge >= 7 and conf >= 0.6:
            return "STRONG"
        elif edge >= 5 and conf >= 0.5:
            return "GOOD"
        elif edge >= 3 and conf >= 0.4:
            return "MODERATE"
        elif edge > 0:
            return "WEAK"
        elif edge <= -5:
            return "FADE"
        else:
            return "NEUTRAL"
    
    @computed_field
    @property
    def is_bet_worthy(self) -> bool:
        """True si l'edge justifie un pari."""
        return self.total_edge_pct >= 3 and self.confidence >= 0.5
    
    @computed_field
    @property
    def recommended_stake(self) -> str:
        """Taille de mise recommandée."""
        if not self.is_bet_worthy:
            return "SKIP"
        
        edge = self.total_edge_pct
        if edge >= 10:
            return "LARGE"
        elif edge >= 7:
            return "MEDIUM"
        else:
            return "SMALL"


# ═══════════════════════════════════════════════════════════════════════════════════════
# TIMING EXPLOITS
# ═══════════════════════════════════════════════════════════════════════════════════════

class TimingExploits(BaseModel):
    """
    Faiblesses timing exploitables.
    """
    
    model_config = ConfigDict(frozen=False)
    
    # Vulnérabilités par période
    weak_first_15: bool = Field(default=False)
    weak_last_15: bool = Field(default=False)
    weak_first_half: bool = Field(default=False)
    weak_second_half: bool = Field(default=False)
    
    # Données
    goals_conceded_first_15_pct: float = Field(default=0, ge=0, le=100)
    goals_conceded_last_15_pct: float = Field(default=0, ge=0, le=100)
    goals_conceded_first_half_pct: float = Field(default=50, ge=0, le=100)
    
    # Pour attaque
    goals_scored_last_15_pct: float = Field(default=0, ge=0, le=100)
    
    @computed_field
    @property
    def best_timing_bet(self) -> str:
        """Meilleur pari timing."""
        if self.weak_last_15:
            return "GOAL_76_90"
        elif self.weak_first_15:
            return "GOAL_0_15"
        elif self.weak_second_half:
            return "2H_OVER"
        elif self.weak_first_half:
            return "1H_OVER"
        else:
            return "NONE"


# ═══════════════════════════════════════════════════════════════════════════════════════
# SET PIECE EXPLOITS
# ═══════════════════════════════════════════════════════════════════════════════════════

class SetPieceExploits(BaseModel):
    """
    Vulnérabilités sur coups de pied arrêtés.
    """
    
    model_config = ConfigDict(frozen=False)
    
    # Défensif
    goals_from_set_pieces_pct: float = Field(default=20, ge=0, le=100)
    corners_conceded_per_match: float = Field(default=0, ge=0)
    aerial_duels_lost_pct: float = Field(default=0, ge=0, le=100)
    
    # Offensif (capacité à exploiter)
    goals_from_set_pieces_scored_pct: float = Field(default=0, ge=0, le=100)
    set_piece_xg_per_match: float = Field(default=0, ge=0)
    
    @computed_field
    @property
    def set_piece_vulnerability(self) -> str:
        """Niveau de vulnérabilité."""
        if self.goals_from_set_pieces_pct > 35:
            return "CRITICAL"
        elif self.goals_from_set_pieces_pct > 25:
            return "HIGH"
        elif self.goals_from_set_pieces_pct > 15:
            return "MODERATE"
        else:
            return "LOW"
    
    @computed_field
    @property
    def set_piece_strength(self) -> str:
        """Force offensive sur set pieces."""
        if self.goals_from_set_pieces_scored_pct > 30:
            return "ELITE"
        elif self.goals_from_set_pieces_scored_pct > 20:
            return "GOOD"
        else:
            return "AVERAGE"


# ═══════════════════════════════════════════════════════════════════════════════════════
# MATCHUP EXPLOITS
# ═══════════════════════════════════════════════════════════════════════════════════════

class MatchupVulnerabilities(BaseModel):
    """
    Vulnérabilités selon le type d'adversaire.
    """
    
    model_config = ConfigDict(frozen=False)
    
    # Vulnérabilités par style adverse
    weak_vs_pressing: bool = Field(default=False)
    weak_vs_low_block: bool = Field(default=False)
    weak_vs_physical: bool = Field(default=False)
    weak_vs_counter: bool = Field(default=False)
    weak_vs_aerial: bool = Field(default=False)
    
    # Données associées
    ppg_vs_pressing_teams: float = Field(default=0, ge=0)
    ppg_vs_low_block_teams: float = Field(default=0, ge=0)
    ppg_vs_physical_teams: float = Field(default=0, ge=0)
    
    @computed_field
    @property
    def primary_matchup_weakness(self) -> str:
        """Faiblesse matchup principale."""
        if self.weak_vs_pressing:
            return "PRESSING"
        elif self.weak_vs_counter:
            return "COUNTER"
        elif self.weak_vs_aerial:
            return "AERIAL"
        elif self.weak_vs_physical:
            return "PHYSICAL"
        elif self.weak_vs_low_block:
            return "LOW_BLOCK"
        else:
            return "NONE"


# ═══════════════════════════════════════════════════════════════════════════════════════
# EXPLOIT PROFILE - Classe principale
# ═══════════════════════════════════════════════════════════════════════════════════════

class ExploitProfile(QuantumBaseModel):
    """
    Profil d'exploitation complet d'une équipe.
    
    Synthèse de toutes les faiblesses détectées et
    mapping vers les marchés avec edges calculés.
    """
    
    # Identité
    team_name: str
    team_normalized: str = ""
    
    # Faiblesses identifiées
    weaknesses: List[IdentifiedWeakness] = Field(default_factory=list)
    
    # Edges par marché
    market_edges: Dict[str, MarketEdge] = Field(default_factory=dict)
    
    # Sub-exploits
    timing: TimingExploits = Field(default_factory=TimingExploits)
    set_pieces: SetPieceExploits = Field(default_factory=SetPieceExploits)
    matchups: MatchupVulnerabilities = Field(default_factory=MatchupVulnerabilities)
    
    # Summary
    total_weaknesses_count: int = Field(default=0, ge=0)
    critical_weaknesses_count: int = Field(default=0, ge=0)
    actionable_markets_count: int = Field(default=0, ge=0)
    
    # Metadata
    data_quality: DataQuality = Field(default=DataQuality.MODERATE)
    last_updated: datetime = Field(default_factory=datetime.utcnow)
    
    @computed_field
    @property
    def critical_weaknesses(self) -> List[IdentifiedWeakness]:
        """Faiblesses critiques seulement."""
        return [w for w in self.weaknesses if w.severity == "CRITICAL"]
    
    @computed_field
    @property
    def actionable_weaknesses(self) -> List[IdentifiedWeakness]:
        """Faiblesses actionnables."""
        return [w for w in self.weaknesses if w.is_actionable]
    
    @computed_field
    @property
    def best_markets(self) -> List[str]:
        """Meilleurs marchés à exploiter (edges > 5%)."""
        return [
            market for market, edge in self.market_edges.items()
            if edge.total_edge_pct >= 5 and edge.confidence >= 0.5
        ]
    
    @computed_field
    @property
    def fade_markets(self) -> List[str]:
        """Marchés à éviter (edges négatifs)."""
        return [
            market for market, edge in self.market_edges.items()
            if edge.total_edge_pct <= -5
        ]
    
    @computed_field
    @property
    def exploitation_score(self) -> float:
        """
        Score d'exploitabilité (0-100).
        Plus haut = plus de faiblesses à exploiter.
        """
        base = 50
        
        # Bonus par faiblesse critique
        base += self.critical_weaknesses_count * 15
        
        # Bonus par marché actionnable
        base += self.actionable_markets_count * 5
        
        # Bonus pour vulnérabilités spécifiques
        if self.set_pieces.set_piece_vulnerability in ["CRITICAL", "HIGH"]:
            base += 10
        
        if self.timing.weak_last_15:
            base += 8
        
        if self.matchups.primary_matchup_weakness != "NONE":
            base += 5
        
        return round(min(100, base), 1)
    
    @computed_field
    @property
    def top_exploit_opportunity(self) -> Optional[dict]:
        """Meilleure opportunité d'exploitation."""
        if not self.market_edges:
            return None
        
        # Trouver le meilleur edge
        best_market = None
        best_edge = -100
        
        for market, edge in self.market_edges.items():
            if edge.total_edge_pct > best_edge and edge.is_bet_worthy:
                best_edge = edge.total_edge_pct
                best_market = market
        
        if best_market is None:
            return None
        
        return {
            "market": best_market,
            "edge": best_edge,
            "confidence": self.market_edges[best_market].confidence,
            "stake": self.market_edges[best_market].recommended_stake,
        }
    
    def get_edge_for_market(self, market: str) -> Optional[MarketEdge]:
        """Récupère l'edge pour un marché spécifique."""
        return self.market_edges.get(market)
    
    def has_weakness(self, weakness_type: str) -> bool:
        """Vérifie si une faiblesse spécifique existe."""
        return any(w.weakness_type == weakness_type for w in self.weaknesses)
    
    @computed_field
    @property
    def summary(self) -> dict:
        """Résumé rapide du profil d'exploitation."""
        return {
            "team": self.team_name,
            "exploitation_score": self.exploitation_score,
            "critical_weaknesses": self.critical_weaknesses_count,
            "actionable_markets": self.actionable_markets_count,
            "best_market": self.top_exploit_opportunity,
            "set_piece_vuln": self.set_pieces.set_piece_vulnerability,
            "matchup_weakness": self.matchups.primary_matchup_weakness,
            "timing_exploit": self.timing.best_timing_bet,
        }
