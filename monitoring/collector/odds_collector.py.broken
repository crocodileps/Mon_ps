#!/usr/bin/env python3
"""
Collector v2.1 - Avec d√©duplication et filtre 24h
"""
import os
import sys
import json
import time
import requests
import psycopg2
from datetime import datetime, timedelta
from pathlib import Path
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# Configuration
API_KEY = "0ded7830ebf698618017c92e51cfcffc"
SPORTS = os.getenv('SPORTS', 'soccer_epl,soccer_spain_la_liga,soccer_france_ligue_one').split(',')
MIN_SPREAD = float(os.getenv('MIN_SPREAD_THRESHOLD', '5.0'))
EMAIL_FROM = os.getenv('EMAIL_FROM')
EMAIL_TO = os.getenv('EMAIL_TO')
EMAIL_PASSWORD = os.getenv('EMAIL_PASSWORD')

DB_CONFIG = {
    'host': os.getenv('DB_HOST', 'localhost'),
    'port': int(os.getenv('DB_PORT', '5432')),
    'database': os.getenv('DB_NAME'),
    'user': os.getenv('DB_USER'),
    'password': os.getenv('DB_PASSWORD')
}

CACHE_DIR = Path(__file__).parent / 'cache'
CACHE_DIR.mkdir(exist_ok=True)

# Fichier de tracking des alertes d√©j√† envoy√©es
SENT_ALERTS_FILE = CACHE_DIR / 'sent_alerts.json'

def load_sent_alerts():
    """Charger les alertes d√©j√† envoy√©es"""
    if SENT_ALERTS_FILE.exists():
        with open(SENT_ALERTS_FILE, 'r') as f:
            data = json.load(f)
            # Nettoyer les alertes de plus de 48h
            cutoff = (datetime.now() - timedelta(hours=48)).isoformat()
            return {k: v for k, v in data.items() if v > cutoff}
    return {}

def save_sent_alerts(alerts):
    """Sauvegarder les alertes envoy√©es"""
    with open(SENT_ALERTS_FILE, 'w') as f:
        json.dump(alerts, f)

def get_cache_file(sport):
    return CACHE_DIR / f"{sport}_last.json"

def load_last_update(sport):
    cache_file = get_cache_file(sport)
    if cache_file.exists():
        with open(cache_file, 'r') as f:
            return json.load(f)
    return {'last_updated': None, 'quota_remaining': None}

def save_last_update(sport, quota_remaining):
    cache_file = get_cache_file(sport)
    with open(cache_file, 'w') as f:
        json.dump({
            'last_updated': datetime.now().isoformat(),
            'quota_remaining': quota_remaining
        }, f)

def collect_odds_for_sport(sport):
    """Collecter les cotes pour un sport"""
    print(f"[{datetime.now()}] Collecte {sport}...")
    
    url = f"https://api.the-odds-api.com/v4/sports/{sport}/odds"
    params = {
        'apiKey': API_KEY,
        'regions': 'eu',
        'markets': 'h2h',
        'oddsFormat': 'decimal'
    }
    
    try:
        response = requests.get(url, params=params, timeout=30)
        response.raise_for_status()
        
        quota_remaining = int(response.headers.get('x-requests-remaining', 0))
        data = response.json()
        
        save_last_update(sport, quota_remaining)
        
        # Filtrer matchs < 24h
        now = datetime.now()
        cutoff = (now + timedelta(hours=24))
        
        filtered_data = []
        for match in data:
            commence_time = datetime.fromisoformat(match["commence_time"].replace("Z", "+00:00")).replace(tzinfo=None)
            if commence_time <= cutoff:
                filtered_data.append(match)
        
        print(f"‚úÖ {len(filtered_data)} matchs collect√©s (< 24h), quota restant: {quota_remaining}")
        return filtered_data, quota_remaining
        
    except Exception as e:
        print(f"‚ùå Erreur collecte {sport}: {e}")
        return [], None

def save_to_database(sport, matches_data):
    """Sauvegarder dans PostgreSQL"""
    if not matches_data:
        return 0
    
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor()
    
    inserted = 0
    for match in matches_data:
        match_id = match['id']
        home_team = match['home_team']
        away_team = match['away_team']
        commence_time = match['commence_time']
        
        for bookmaker in match.get('bookmakers', []):
            bookmaker_name = bookmaker['key']
            
            for market in bookmaker.get('markets', []):
                if market['key'] != 'h2h':
                    continue
                    
                for outcome in market.get('outcomes', []):
                    try:
                        cursor.execute("""
                            INSERT INTO odds_history (
                                match_id, sport, home_team, away_team,
                                bookmaker, outcome, odds_value, commence_time
                            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                            ON CONFLICT (match_id, bookmaker, outcome, created_at) 
                            DO NOTHING
                        """, (
                            match_id, sport, home_team, away_team,
                            bookmaker_name, outcome['name'], 
                            outcome['price'], commence_time
                        ))
                        inserted += cursor.rowcount
                    except Exception as e:
                        print(f"Erreur insertion: {e}")
    
    conn.commit()
    cursor.close()
    conn.close()
    
    return inserted

def check_opportunities_and_alert():
    """V√©rifier les opportunit√©s et envoyer UN email group√©"""
    conn = psycopg2.connect(**DB_CONFIG)
    cursor = conn.cursor()
    
    # Charger les alertes d√©j√† envoy√©es
    sent_alerts = load_sent_alerts()
    
    # Chercher opportunit√©s < 24h avec spread > 5%
    cursor.execute("""
        WITH odds_stats AS (
            SELECT
                match_id,
                home_team,
                away_team,
                sport,
                commence_time,
                outcome,
                MIN(odds_value) as min_odd,
                MAX(odds_value) as max_odd,
                COUNT(DISTINCT bookmaker) as nb_bookmakers
            FROM odds
            WHERE commence_time > NOW() 
              AND commence_time < NOW() + INTERVAL '24 hours'
            GROUP BY match_id, home_team, away_team, sport, commence_time, outcome
            HAVING COUNT(DISTINCT bookmaker) >= 3
        )
        SELECT
            match_id,
            home_team,
            away_team,
            sport,
            commence_time,
            outcome,
            max_odd,
            min_odd,
            ((max_odd - min_odd) / min_odd * 100) as spread_pct,
            nb_bookmakers
        FROM odds_stats
        WHERE ((max_odd - min_odd) / min_odd * 100) >= %s
        ORDER BY spread_pct DESC
        LIMIT 10
    """, (MIN_SPREAD,))
    
    opportunities = cursor.fetchall()
    cursor.close()
    conn.close()
    
    if not opportunities:
        print("Aucune opportunit√© d√©tect√©e")
        return
    
    # Filtrer les nouvelles opportunit√©s
    new_opportunities = []
    for opp in opportunities:
        match_id, home, away, sport, commence, outcome, max_odd, min_odd, spread, nb_bk = opp
        
        # Cr√©er une cl√© unique
        alert_key = f"{match_id}_{outcome}_{int(spread)}"
        
        # V√©rifier si d√©j√† envoy√©e
        if alert_key not in sent_alerts:
            new_opportunities.append(opp)
            sent_alerts[alert_key] = datetime.now().isoformat()
    
    if not new_opportunities:
        print(f"{len(opportunities)} opportunit√©s trouv√©es mais d√©j√† alert√©es")
        return
    
    # Sauvegarder les alertes
    save_sent_alerts(sent_alerts)
    
    # Envoyer UN email group√©
    send_grouped_email(new_opportunities)

def send_grouped_email(opportunities):
    """Envoyer UN email avec toutes les opportunit√©s"""
    html = """
    <html>
    <body style="font-family: Arial, sans-serif;">
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; color: white;">
            <h1>üí∞ Mon_PS Trading</h1>
            <h2>Nouvelles Opportunit√©s D√©tect√©es</h2>
        </div>
        <div style="padding: 20px;">
            <p><strong>{} opportunit√©s √† analyser dans les 24h</strong></p>
    """.format(len(opportunities))
    
    for opp in opportunities:
        match_id, home, away, sport, commence, outcome, max_odd, min_odd, spread, nb_bk = opp
        
        html += f"""
        <div style="border-left: 4px solid #667eea; padding: 15px; margin: 15px 0; background: #f8f9fa;">
            <h3 style="margin: 0 0 10px 0;">üèÜ {home} vs {away}</h3>
            <p><strong>Sport:</strong> {sport.replace('soccer_', '').replace('_', ' ').title()}</p>
            <p><strong>Pari sugg√©r√©:</strong> {outcome}</p>
            <p><strong>Spread:</strong> <span style="color: #667eea; font-size: 1.2em; font-weight: bold;">{spread:.1f}%</span></p>
            <p><strong>Cotes:</strong> {max_odd:.2f} ‚Üí {min_odd:.2f}</p>
            <p><strong>Bookmakers:</strong> {nb_bk}</p>
            <p><strong>Commence:</strong> {commence.strftime('%d/%m/%Y %H:%M')}</p>
        </div>
        """
    
    html += """
        </div>
    </body>
    </html>
    """
    
    msg = MIMEMultipart('alternative')
    msg['Subject'] = f"[MON_PS] {len(opportunities)} opportunit√©s d√©tect√©es (<24h)"
    msg['From'] = EMAIL_FROM
    msg['To'] = EMAIL_TO
    msg.attach(MIMEText(html, 'html'))
    
    try:
        server = smtplib.SMTP('smtp.gmail.com', 587)
        server.starttls()
        server.login(EMAIL_FROM, EMAIL_PASSWORD)
        server.send_message(msg)
        server.quit()
        print(f"‚úÖ Email envoy√© : {len(opportunities)} opportunit√©s")
    except Exception as e:
        print(f"‚ùå Erreur email: {e}")

def main():
    print("=" * 60)
    print(f"COLLECTOR v2.1 - {datetime.now()}")
    print("=" * 60)
    
    total_inserted = 0
    
    for sport in SPORTS:
        matches, quota = collect_odds_for_sport(sport)
        inserted = save_to_database(sport, matches)
        total_inserted += inserted
        
        if quota and quota < 100:
            print(f"‚ö†Ô∏è  Quota API faible: {quota} requ√™tes restantes")
    
    print(f"\n‚úÖ {total_inserted} nouvelles cotes ins√©r√©es")
    
    # V√©rifier opportunit√©s
    check_opportunities_and_alert()
    
    print("=" * 60)

if __name__ == '__main__':
    main()
