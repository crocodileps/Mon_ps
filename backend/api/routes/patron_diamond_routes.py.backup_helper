"""
Routes API pour Agent PATRON Diamond+ V3
Endpoints pour analyse multi-march√©s (1X2, BTTS, Over 2.5)
"""
from fastapi import APIRouter, HTTPException
from typing import Optional
import psycopg2
from psycopg2.extras import RealDictCursor
import math
import json
from datetime import datetime

from api.services.odds_retriever import get_match_odds

# Reality Check Integration
try:
    from agents.reality_check import RealityChecker
    _reality_checker = RealityChecker()
    REALITY_CHECK_ENABLED = True
except ImportError:
    _reality_checker = None
    REALITY_CHECK_ENABLED = False
router = APIRouter(prefix="/patron-diamond", tags=["Patron Diamond V3"])

# Configuration DB
DB_CONFIG = {
    'host': 'monps_postgres',
    'port': 5432,
    'database': 'monps_db',
    'user': 'monps_user',
    'password': 'monps_secure_password_2024'
}


# ============================================================
# HELPERS
# ============================================================

def poisson_prob(lam: float, k: int) -> float:
    """Probabilit√© Poisson P(X=k)"""
    if lam <= 0:
        return 1.0 if k == 0 else 0.0
    return (lam ** k) * math.exp(-lam) / math.factorial(k)


def calculate_poisson(home_xg: float, away_xg: float) -> dict:
    """Calcule probabilit√©s via Poisson"""
    max_goals = 7
    btts = over15 = over25 = over35 = 0
    home_win = draw = away_win = 0
    score_probs = {}
    
    for h in range(max_goals + 1):
        for a in range(max_goals + 1):
            prob = poisson_prob(home_xg, h) * poisson_prob(away_xg, a)
            score_probs[f"{h}-{a}"] = prob
            
            if h > a: home_win += prob
            elif h == a: draw += prob
            else: away_win += prob
            
            if h > 0 and a > 0: btts += prob
            total = h + a
            if total > 1: over15 += prob
            if total > 2: over25 += prob
            if total > 3: over35 += prob
    

    # ===== NOUVEAUX MARCH√âS PHASE 1 =====
    # Under (inverse des Over)
    under15 = 1 - over15
    under25 = 1 - over25
    under35 = 1 - over35
    
    # BTTS No
    btts_no = 1 - btts
    
    # Double Chance
    dc_1x = home_win + draw
    dc_x2 = draw + away_win
    dc_12 = home_win + away_win
    
    # Draw No Bet
    total_no_draw = home_win + away_win
    dnb_home = home_win / total_no_draw if total_no_draw > 0 else 0.5
    dnb_away = away_win / total_no_draw if total_no_draw > 0 else 0.5
    # ===== FIN NOUVEAUX MARCH√âS =====
    sorted_scores = sorted(score_probs.items(), key=lambda x: x[1], reverse=True)[:5]
    
    return {
        'btts_prob': round(btts * 100, 1),
        'over15_prob': round(over15 * 100, 1),
        'over25_prob': round(over25 * 100, 1),
        'over35_prob': round(over35 * 100, 1),
        '1x2': {
            'home': round(home_win * 100, 1),
            'draw': round(draw * 100, 1),
            'away': round(away_win * 100, 1)
        },
        'most_likely_scores': [(s, round(p * 100, 1)) for s, p in sorted_scores],
        # NOUVEAUX MARCH√âS
        'btts_no_prob': round(btts_no * 100, 1),
        'under15_prob': round(under15 * 100, 1),
        'under25_prob': round(under25 * 100, 1),
        'under35_prob': round(under35 * 100, 1),
        'double_chance': {
            '1x': round(dc_1x * 100, 1),
            'x2': round(dc_x2 * 100, 1),
            '12': round(dc_12 * 100, 1)
        },
        'draw_no_bet': {
            'home': round(dnb_home * 100, 1),
            'away': round(dnb_away * 100, 1)
        }
    }


def safe_float(value, default: float = 0.0) -> float:
    if value is None:
        return default
    try:
        return float(value)
    except:
        return default


def get_team_stats(team_name: str) -> Optional[dict]:
    """R√©cup√®re stats √©quipe depuis team_statistics_live"""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # Essayer nom exact puis partiel
        cur.execute("""
            SELECT * FROM team_statistics_live 
            WHERE team_name = %s OR team_name ILIKE %s
            LIMIT 1
        """, (team_name, f"%{team_name.split()[0]}%"))
        
        row = cur.fetchone()
        cur.close()
        conn.close()
        return dict(row) if row else None
    except:
        return None


def get_h2h_stats(team_a: str, team_b: str) -> Optional[dict]:
    """R√©cup√®re H2H"""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        t1, t2 = sorted([team_a, team_b])
        cur.execute("""
            SELECT * FROM team_head_to_head 
            WHERE (team_a ILIKE %s AND team_b ILIKE %s)
               OR (team_a ILIKE %s AND team_b ILIKE %s)
            LIMIT 1
        """, (f"%{t1.split()[0]}%", f"%{t2.split()[0]}%",
              f"%{t2.split()[0]}%", f"%{t1.split()[0]}%"))
        
        row = cur.fetchone()
        cur.close()
        conn.close()
        return dict(row) if row else None
    except:
        return None


def get_recommendation(score: float, confidence: int) -> str:
    """G√©n√®re recommandation bas√©e sur score et confidence"""
    if score >= 75 and confidence >= 70:
        return "üíé DIAMOND PICK"
    elif score >= 65 and confidence >= 60:
        return "‚úÖ STRONG BET"
    elif score >= 55:
        return "üìà LEAN YES"
    elif score >= 45:
        return "‚è≠Ô∏è SKIP"
    else:
        return "‚ùå AVOID"


def get_value_rating(score: float, odds: float) -> str:
    """Calcule le rating de value"""
    if not odds or odds <= 1:
        return "N/A"
    
    implied = 100 / odds
    edge = score - implied
    
    if edge >= 15:
        return "üíé DIAMOND VALUE"
    elif edge >= 10:
        return "üî• STRONG VALUE"
    elif edge >= 5:
        return "‚úÖ VALUE"
    elif edge >= 0:
        return "‚öñÔ∏è FAIR"
    else:
        return "‚ùå AVOID"


def calculate_kelly(prob: float, odds: float) -> float:
    """Kelly Criterion"""
    if not odds or odds <= 1 or prob <= 0:
        return 0.0
    
    p = prob / 100
    b = odds - 1
    q = 1 - p
    
    kelly = (b * p - q) / b
    kelly *= 0.25  # Fractional Kelly
    
    return max(0, min(10, kelly * 100))


def log_prediction(match_id: str, home_team: str, away_team: str,
                   market: str, score: float, probability: float,
                   recommendation: str, confidence: str, value_rating: str,
                   kelly: float, factors: dict, reasoning: str):
    """Log pr√©diction pour CLV tracking"""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cur = conn.cursor()
        
        cur.execute("""
            INSERT INTO market_predictions 
            (match_id, home_team, away_team, market, predicted_score, 
             predicted_probability, recommendation, confidence, value_rating,
             kelly_pct, factors, reasoning)
            VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            ON CONFLICT DO NOTHING
        """, (
            match_id, home_team, away_team, market,
            score, probability, recommendation, confidence,
            value_rating, kelly, json.dumps(factors), reasoning
        ))
        
        conn.commit()
        cur.close()
        conn.close()
    except Exception as e:
        print(f"Log error: {e}")


# ============================================================
# ENDPOINTS
# ============================================================

@router.get("/health")
async def patron_diamond_health():
    """V√©rifie le statut du Patron Diamond V3"""
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cur = conn.cursor()
        
        cur.execute("SELECT COUNT(*) FROM team_statistics_live")
        teams_count = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM team_head_to_head")
        h2h_count = cur.fetchone()[0]
        
        cur.execute("SELECT COUNT(*) FROM match_results WHERE is_finished = true")
        matches_count = cur.fetchone()[0]
        
        cur.close()
        conn.close()
        
        return {
            "status": "operational",
            "version": "3.0.0",
            "name": "Patron Diamond+ V3",
            "features": ["Poisson Model", "BTTS", "Over 2.5", "Kelly", "Value Detection"],
            "data": {
                "teams": teams_count,
                "h2h_pairs": h2h_count,
                "matches": matches_count
            }
        }
    except Exception as e:
        return {"status": "error", "error": str(e)}
@router.get("/analyze/{match_id}")

async def analyze_match_diamond(
    match_id: str,
    odds_btts: float = None,
    odds_btts_no: float = None,
    odds_over15: float = None,
    odds_under15: float = None,
    odds_over25: float = None,
    odds_under25: float = None,
    odds_over35: float = None,
    odds_under35: float = None,
    odds_dc_1x: float = None,
    odds_dc_x2: float = None,
    odds_dc_12: float = None,
    odds_dnb_home: float = None,
    odds_dnb_away: float = None
):
    """
    Analyse compl√®te d'un match avec Patron Diamond V3
    
    - Mod√®le Poisson pour probabilit√©s exactes
    - Analyse BTTS et Over 2.5
    - Value Bet detection
    - Kelly Criterion
    """
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        # R√©cup√©rer info match
        cur.execute("""
            SELECT DISTINCT match_id, home_team, away_team, sport, commence_time
            FROM odds_history WHERE match_id = %s LIMIT 1
        """, (match_id,))
        
        match_row = cur.fetchone()
        if not match_row:
            cur.close()
            conn.close()
            raise HTTPException(status_code=404, detail=f"Match {match_id} not found")
        
        home_team = match_row['home_team']
        away_team = match_row['away_team']
        
        cur.close()
        
        # üí∞ Auto-r√©cup√©rer les odds de la DB
        db_odds = get_match_odds(match_id)
        odds_btts = odds_btts or db_odds.get("odds_btts")
        odds_btts_no = odds_btts_no or db_odds.get("odds_btts_no")
        odds_over15 = odds_over15 or db_odds.get("odds_over15")
        odds_under15 = odds_under15 or db_odds.get("odds_under15")
        odds_over25 = odds_over25 or db_odds.get("odds_over25")
        odds_under25 = odds_under25 or db_odds.get("odds_under25")
        odds_over35 = odds_over35 or db_odds.get("odds_over35")
        odds_under35 = odds_under35 or db_odds.get("odds_under35")
        odds_dc_1x = odds_dc_1x or db_odds.get("odds_dc_1x")
        odds_dc_x2 = odds_dc_x2 or db_odds.get("odds_dc_x2")
        odds_dc_12 = odds_dc_12 or db_odds.get("odds_dc_12")
        odds_dnb_home = odds_dnb_home or db_odds.get("odds_dnb_home")
        odds_dnb_away = odds_dnb_away or db_odds.get("odds_dnb_away")

        conn.close()
        
        # R√©cup√©rer stats √©quipes
        home_stats = get_team_stats(home_team)
        away_stats = get_team_stats(away_team)
        h2h = get_h2h_stats(home_team, away_team)
        
        # Calculer xG
        home_xg = 1.5
        away_xg = 1.2
        
        if home_stats and away_stats:
            home_scored = safe_float(home_stats.get('home_avg_scored'), 1.5)
            away_conceded = safe_float(away_stats.get('away_avg_conceded'), 1.5)
            home_xg = (home_scored + away_conceded) / 2 * 1.15
            
            away_scored = safe_float(away_stats.get('away_avg_scored'), 1.2)
            home_conceded = safe_float(home_stats.get('home_avg_conceded'), 1.2)
            away_xg = (away_scored + home_conceded) / 2 / 1.15
        
        home_xg = max(0.5, min(4.0, home_xg))
        away_xg = max(0.3, min(3.5, away_xg))
        total_xg = home_xg + away_xg
        
        # Poisson
        poisson = calculate_poisson(home_xg, away_xg)
        
        # ========== BTTS ANALYSIS ==========
        btts_factors = {'poisson': poisson['btts_prob']}
        btts_score = poisson['btts_prob'] * 0.35  # Poisson 35%
        
        if home_stats and away_stats:
            home_btts = safe_float(home_stats.get('btts_pct'), 50)
            away_btts = safe_float(away_stats.get('btts_pct'), 50)
            global_btts = (home_btts + away_btts) / 2
            btts_factors['stats_global'] = global_btts
            btts_score += global_btts * 0.25
            
            home_l5 = safe_float(home_stats.get('last5_btts_pct'), 50)
            away_l5 = safe_float(away_stats.get('last5_btts_pct'), 50)
            l5_btts = (home_l5 + away_l5) / 2
            btts_factors['form_l5'] = l5_btts
            btts_score += l5_btts * 0.15
            
            # P√©nalit√© clean sheets
            home_cs = safe_float(home_stats.get('home_clean_sheet_pct'), 25)
            away_cs = safe_float(away_stats.get('away_clean_sheet_pct'), 20)
            cs_penalty = (home_cs + away_cs) / 8
            btts_factors['cs_penalty'] = cs_penalty
            btts_score -= cs_penalty
        else:
            btts_score += 50 * 0.40
        
        if h2h:
            h2h_btts = safe_float(h2h.get('btts_pct'), 50)
            btts_factors['h2h'] = h2h_btts
            btts_score += h2h_btts * 0.25
        else:
            btts_score += 50 * 0.25
        
        btts_score = max(0, min(100, btts_score))
        
        # Confidence BTTS
        btts_confidence = 30
        if home_stats: btts_confidence += 25
        if away_stats: btts_confidence += 25
        if h2h: btts_confidence += 20
        
        btts_recommendation = get_recommendation(btts_score, btts_confidence)
        btts_value = get_value_rating(btts_score, odds_btts) if odds_btts else "N/A"
        btts_kelly = calculate_kelly(btts_score, odds_btts) if odds_btts else 0
        
        btts_reasoning = f"BTTS {'probable' if btts_score >= 55 else 'incertain'} ({btts_score:.0f}%). "
        btts_reasoning += f"Poisson: {poisson['btts_prob']}%. "
        if home_stats:
            btts_reasoning += f"Stats: {btts_factors.get('stats_global', 50):.0f}%."
        
        # ========== OVER 2.5 ANALYSIS ==========
        over_factors = {'poisson': poisson['over25_prob'], 'xg_total': total_xg}
        over_score = poisson['over25_prob'] * 0.40  # Poisson 40%
        
        # xG factor
        xg_factor = min(100, max(0, (total_xg - 2.5) * 40 + 50))
        over_factors['xg_factor'] = xg_factor
        over_score += xg_factor * 0.20
        
        if home_stats and away_stats:
            home_over = safe_float(home_stats.get('over_25_pct'), 50)
            away_over = safe_float(away_stats.get('over_25_pct'), 50)
            global_over = (home_over + away_over) / 2
            over_factors['stats_global'] = global_over
            over_score += global_over * 0.15
            
            home_l5 = safe_float(home_stats.get('last5_over25_pct'), 50)
            away_l5 = safe_float(away_stats.get('last5_over25_pct'), 50)
            l5_over = (home_l5 + away_l5) / 2
            over_factors['form_l5'] = l5_over
            over_score += l5_over * 0.10
        else:
            over_score += 50 * 0.25
        
        if h2h:
            h2h_over = safe_float(h2h.get('over_25_pct'), 50)
            over_factors['h2h'] = h2h_over
            over_score += h2h_over * 0.15
        else:
            over_score += 50 * 0.15
        
        over_score = max(0, min(100, over_score))
        
        # Confidence Over
        over_confidence = 30
        if home_stats: over_confidence += 25
        if away_stats: over_confidence += 25
        if h2h: over_confidence += 20
        
        over_recommendation = get_recommendation(over_score, over_confidence)
        over_value = get_value_rating(over_score, odds_over25) if odds_over25 else "N/A"
        over_kelly = calculate_kelly(over_score, odds_over25) if odds_over25 else 0
        
        over_reasoning = f"Over 2.5 {'probable' if over_score >= 55 else 'incertain'} ({over_score:.0f}%). "
        over_reasoning += f"xG: {total_xg:.2f}, Poisson: {poisson['over25_prob']}%."

        # ========== BTTS NO ANALYSIS ==========
        btts_no_score = 100 - btts_score
        btts_no_recommendation = get_recommendation(btts_no_score, btts_confidence)
        btts_no_reasoning = f"BTTS No {'probable' if btts_no_score >= 55 else 'incertain'} ({btts_no_score:.0f}%). Inverse de BTTS Yes."
        btts_no_value = get_value_rating(btts_no_score, odds_btts_no) if odds_btts_no else "N/A"
        btts_no_kelly = calculate_kelly(btts_no_score, odds_btts_no) if odds_btts_no else 0

        # ========== UNDER 2.5 ANALYSIS ==========
        under25_score = 100 - over_score
        under25_recommendation = get_recommendation(under25_score, over_confidence)
        under25_value = get_value_rating(under25_score, odds_under25) if odds_under25 else "N/A"
        under25_kelly = calculate_kelly(under25_score, odds_under25) if odds_under25 else 0
        under25_reasoning = f"Under 2.5 {'probable' if under25_score >= 55 else 'incertain'} ({under25_score:.0f}%). xG: {total_xg:.2f}."

        # ========== DOUBLE CHANCE ANALYSIS ==========
        dc_1x_score = poisson['double_chance']['1x']
        dc_x2_score = poisson['double_chance']['x2']
        dc_12_score = poisson['double_chance']['12']
        
        dc_confidence = 40
        if home_stats: dc_confidence += 20
        if away_stats: dc_confidence += 20
        if h2h: dc_confidence += 20

        dc_1x_recommendation = get_recommendation(dc_1x_score, dc_confidence)
        dc_x2_recommendation = get_recommendation(dc_x2_score, dc_confidence)
        dc_12_recommendation = get_recommendation(dc_12_score, dc_confidence)

        # ========== DRAW NO BET ANALYSIS ==========
        dnb_home_score = poisson['draw_no_bet']['home']
        dnb_away_score = poisson['draw_no_bet']['away']
        
        dnb_home_recommendation = get_recommendation(dnb_home_score, dc_confidence)

        # ========== OVER 1.5 ANALYSIS ==========
        over15_score = poisson['over15_prob'] * 0.40
        xg15_factor = min(100, max(0, (total_xg - 1.5) * 50 + 50))
        over15_score += xg15_factor * 0.30
        if home_stats and away_stats:
            home_avg = safe_float(home_stats.get('avg_goals_scored'), 1.5)
            away_avg = safe_float(away_stats.get('avg_goals_scored'), 1.0)
            avg_goals = home_avg + away_avg
            over15_score += min(100, avg_goals * 25) * 0.30
        else:
            over15_score += 50 * 0.30
        over15_score = max(0, min(100, over15_score))
        over15_recommendation = get_recommendation(over15_score, over_confidence)
        over15_reasoning = f"Over 1.5 {'probable' if over15_score >= 55 else 'incertain'} ({over15_score:.0f}%). xG: {total_xg:.2f}."
        over15_value = get_value_rating(over15_score, odds_over15) if odds_over15 else "N/A"
        over15_kelly = calculate_kelly(over15_score, odds_over15) if odds_over15 else 0

        # ========== UNDER 1.5 ANALYSIS ==========
        under15_score = 100 - over15_score
        under15_recommendation = get_recommendation(under15_score, over_confidence)
        under15_reasoning = f"Under 1.5 {'probable' if under15_score >= 55 else 'incertain'} ({under15_score:.0f}%). Inverse Over 1.5."
        under15_value = get_value_rating(under15_score, odds_under15) if odds_under15 else "N/A"
        under15_kelly = calculate_kelly(under15_score, odds_under15) if odds_under15 else 0

        # ========== OVER 3.5 ANALYSIS ==========
        over35_score = poisson['over35_prob'] * 0.45
        xg35_factor = min(100, max(0, (total_xg - 3.5) * 40 + 30))
        over35_score += xg35_factor * 0.35
        if home_stats and away_stats:
            home_high = safe_float(home_stats.get('over_25_pct'), 50)
            away_high = safe_float(away_stats.get('over_25_pct'), 50)
            high_scoring = (home_high + away_high) / 2
            over35_score += high_scoring * 0.20
        else:
            over35_score += 40 * 0.20
        over35_score = max(0, min(100, over35_score))
        over35_recommendation = get_recommendation(over35_score, over_confidence)
        over35_reasoning = f"Over 3.5 {'probable' if over35_score >= 55 else 'incertain'} ({over35_score:.0f}%). xG: {total_xg:.2f}."

        # ========== UNDER 3.5 ANALYSIS ==========
        over35_value = get_value_rating(over35_score, odds_over35) if odds_over35 else "N/A"
        over35_kelly = calculate_kelly(over35_score, odds_over35) if odds_over35 else 0
        under35_score = 100 - over35_score
        under35_recommendation = get_recommendation(under35_score, over_confidence)
        under35_reasoning = f"Under 3.5 {'probable' if under35_score >= 55 else 'incertain'} ({under35_score:.0f}%). Inverse Over 3.5."

        # ========== ENRICHIR DC avec stats + H2H + Form ==========
        under35_value = get_value_rating(under35_score, odds_under35) if odds_under35 else "N/A"
        under35_kelly = calculate_kelly(under35_score, odds_under35) if odds_under35 else 0
        if home_stats and away_stats:
            home_win_pct = safe_float(home_stats.get('home_win_pct'), 40)
            away_win_pct = safe_float(away_stats.get('away_win_pct'), 30)
            home_draw_pct = safe_float(home_stats.get('draw_pct'), 25)
            away_draw_pct = safe_float(away_stats.get('draw_pct'), 25)
            # Form last5
            home_form = safe_float(home_stats.get('last5_form_points'), 7.5) / 15 * 100
            away_form = safe_float(away_stats.get('last5_form_points'), 7.5) / 15 * 100
            # Enrichir DC avec pond√©ration: 40% Poisson + 30% stats + 15% form + 15% H2H
            dc_1x_score = dc_1x_score * 0.40 + (home_win_pct + home_draw_pct) * 0.30 + home_form * 0.15
            dc_x2_score = dc_x2_score * 0.40 + (away_win_pct + away_draw_pct) * 0.30 + away_form * 0.15
            dc_12_score = dc_12_score * 0.40 + (home_win_pct + away_win_pct) * 0.30 + ((home_form + away_form) / 2) * 0.15
        else:
            dc_1x_score = dc_1x_score * 0.55
            dc_x2_score = dc_x2_score * 0.55
            dc_12_score = dc_12_score * 0.55
        # Ajouter H2H au DC
        if h2h:
            h2h_home_win = safe_float(h2h.get('team_a_wins'), 2) / max(1, safe_float(h2h.get('total_matches'), 5)) * 100
            h2h_away_win = safe_float(h2h.get('team_b_wins'), 2) / max(1, safe_float(h2h.get('total_matches'), 5)) * 100
            h2h_draws = safe_float(h2h.get('draws'), 1) / max(1, safe_float(h2h.get('total_matches'), 5)) * 100
            dc_1x_score += (h2h_home_win + h2h_draws) * 0.15
            dc_x2_score += (h2h_away_win + h2h_draws) * 0.15
            dc_12_score += (h2h_home_win + h2h_away_win) * 0.15
        else:
            dc_1x_score += 50 * 0.15
            dc_x2_score += 50 * 0.15
            dc_12_score += 50 * 0.15
        dc_1x_score = max(0, min(100, dc_1x_score))
        dc_x2_score = max(0, min(100, dc_x2_score))
        dc_12_score = max(0, min(100, dc_12_score))
        # Recalculer recommandations DC
        dc_1x_recommendation = get_recommendation(dc_1x_score, dc_confidence)
        dc_x2_recommendation = get_recommendation(dc_x2_score, dc_confidence)
        dc_12_recommendation = get_recommendation(dc_12_score, dc_confidence)
        dc_1x_value = get_value_rating(dc_1x_score, odds_dc_1x) if odds_dc_1x else "N/A"
        dc_1x_kelly = calculate_kelly(dc_1x_score, odds_dc_1x) if odds_dc_1x else 0
        dc_x2_value = get_value_rating(dc_x2_score, odds_dc_x2) if odds_dc_x2 else "N/A"
        dc_x2_kelly = calculate_kelly(dc_x2_score, odds_dc_x2) if odds_dc_x2 else 0
        dc_12_value = get_value_rating(dc_12_score, odds_dc_12) if odds_dc_12 else "N/A"
        dc_12_kelly = calculate_kelly(dc_12_score, odds_dc_12) if odds_dc_12 else 0
        # ========== ENRICHIR DNB avec stats + H2H + Form ==========
        if home_stats and away_stats:
            dnb_home_score = dnb_home_score * 0.40 + home_win_pct * 0.30 + home_form * 0.15
            dnb_away_score = dnb_away_score * 0.40 + away_win_pct * 0.30 + away_form * 0.15
        else:
            dnb_home_score = dnb_home_score * 0.55
            dnb_away_score = dnb_away_score * 0.55
        # Ajouter H2H au DNB
        if h2h:
            dnb_home_score += h2h_home_win * 0.15
            dnb_away_score += h2h_away_win * 0.15
        else:
            dnb_home_score += 50 * 0.15
            dnb_away_score += 50 * 0.15
        dnb_home_score = max(0, min(100, dnb_home_score))
        dnb_away_score = max(0, min(100, dnb_away_score))
        # Recalculer recommandations DNB
        dnb_home_recommendation = get_recommendation(dnb_home_score, dc_confidence)
        dnb_away_recommendation = get_recommendation(dnb_away_score, dc_confidence)
        dnb_home_value = get_value_rating(dnb_home_score, odds_dnb_home) if odds_dnb_home else "N/A"
        dnb_home_kelly = calculate_kelly(dnb_home_score, odds_dnb_home) if odds_dnb_home else 0
        dnb_away_value = get_value_rating(dnb_away_score, odds_dnb_away) if odds_dnb_away else "N/A"
        dnb_away_kelly = calculate_kelly(dnb_away_score, odds_dnb_away) if odds_dnb_away else 0

        # ========== BEST/WORST MARKET ==========
        all_markets = [
            ('btts', btts_score, btts_recommendation),
            ('btts_no', btts_no_score, btts_no_recommendation),
            ('over15', over15_score, over15_recommendation),
            ('under15', under15_score, under15_recommendation),
            ('over25', over_score, over_recommendation),
            ('under25', under25_score, under25_recommendation),
            ('over35', over35_score, over35_recommendation),
            ('under35', under35_score, under35_recommendation),
            ('dc_1x', dc_1x_score, dc_1x_recommendation),
            ('dc_x2', dc_x2_score, dc_x2_recommendation),
            ('dc_12', dc_12_score, dc_12_recommendation),
            ('dnb_home', dnb_home_score, dnb_home_recommendation),
            ('dnb_away', dnb_away_score, dnb_away_recommendation),
        ]
        best_market = max(all_markets, key=lambda x: x[1])
        worst_market = min(all_markets, key=lambda x: x[1])

        # ========== PATRON SCORE AM√âLIOR√â ==========
        all_scores = [m[1] for m in all_markets]
        patron_score = sum(all_scores) / len(all_scores)
        
        max_score = max(all_scores)
        if max_score >= 70:
            match_interest = "üíé DIAMOND MATCH"
        elif max_score >= 60:
            match_interest = "üî• HIGH INTEREST"
        elif max_score >= 50:
            match_interest = "üìà MEDIUM INTEREST"
        else:
            match_interest = "üìä LOW INTEREST"
        
        # Log predictions
        log_prediction(match_id, home_team, away_team, 'btts',
                      btts_score, poisson['btts_prob'], btts_recommendation,
                      str(btts_confidence), btts_value, btts_kelly,
                      btts_factors, btts_reasoning)
        
        log_prediction(match_id, home_team, away_team, 'over25',
                      over_score, poisson['over25_prob'], over_recommendation,
                      str(over_confidence), over_value, over_kelly,
                      over_factors, over_reasoning)
        
        return {
            "match_id": match_id,
            "home_team": home_team,
            "away_team": away_team,
            
            "poisson": {
                "home_xg": round(home_xg, 2),
                "away_xg": round(away_xg, 2),
                "total_xg": round(total_xg, 2),
                "btts_prob": poisson['btts_prob'],
                "over25_prob": poisson['over25_prob'],
                "over15_prob": poisson['over15_prob'],
                "over35_prob": poisson['over35_prob'],
                "1x2": poisson['1x2'],
                "most_likely_scores": poisson['most_likely_scores'],
                "btts_no_prob": poisson['btts_no_prob'],
                "under15_prob": poisson['under15_prob'],
                "under25_prob": poisson['under25_prob'],
                "under35_prob": poisson['under35_prob'],
                "double_chance": poisson['double_chance'],
                "draw_no_bet": poisson['draw_no_bet']
            },
            
            "btts": {
                "odds": odds_btts or 0,
                "score": round(btts_score, 1),
                "probability": poisson['btts_prob'],
                "recommendation": btts_recommendation,
                "confidence": btts_confidence,
                "value_rating": btts_value,
                "kelly_pct": round(btts_kelly, 2),
                "factors": {k: round(v, 1) if isinstance(v, float) else v 
                           for k, v in btts_factors.items()},
                "reasoning": btts_reasoning
            },
            
            "over25": {
                "odds": odds_over25 or 0,
                "score": round(over_score, 1),
                "probability": poisson['over25_prob'],
                "expected_goals": round(total_xg, 2),
                "recommendation": over_recommendation,
                "confidence": over_confidence,
                "value_rating": over_value,
                "kelly_pct": round(over_kelly, 2),
                "factors": {k: round(v, 1) if isinstance(v, float) else v 
                           for k, v in over_factors.items()},
                "reasoning": over_reasoning
            },
            "btts_no": {
                "odds": odds_btts_no or 0,
                "score": round(btts_no_score, 1),
                "probability": poisson['btts_no_prob'],
                "recommendation": btts_no_recommendation,
                "confidence": btts_confidence,
                "value_rating": btts_no_value,
                "kelly_pct": round(btts_no_kelly, 2),
                "reasoning": btts_no_reasoning
            },
            "under25": {
                "odds": odds_under25 or 0,
                "score": round(under25_score, 1),
                "probability": poisson['under25_prob'],
                "recommendation": under25_recommendation,
                "confidence": over_confidence,
                "value_rating": under25_value,
                "kelly_pct": round(under25_kelly, 2),
                "reasoning": under25_reasoning
            },
            "double_chance": {
                "1x": {
                    "score": round(dc_1x_score, 1),
                    "recommendation": dc_1x_recommendation,
                    "confidence": dc_confidence,
                    "value_rating": dc_1x_value,
                    "kelly_pct": round(dc_1x_kelly, 2)
                },
                "x2": {
                    "score": round(dc_x2_score, 1),
                    "recommendation": dc_x2_recommendation,
                    "confidence": dc_confidence,
                    "value_rating": dc_x2_value,
                    "kelly_pct": round(dc_x2_kelly, 2)
                },
                "12": {
                    "score": round(dc_12_score, 1),
                    "recommendation": dc_12_recommendation,
                    "confidence": dc_confidence,
                    "value_rating": dc_12_value,
                    "kelly_pct": round(dc_12_kelly, 2)
                }
            },
            "draw_no_bet": {
                "home": {
                    "score": round(dnb_home_score, 1),
                    "recommendation": dnb_home_recommendation,
                    "confidence": dc_confidence,
                    "value_rating": dnb_home_value,
                    "kelly_pct": round(dnb_home_kelly, 2)
                },
                "away": {
                    "score": round(dnb_away_score, 1),
                    "recommendation": dnb_away_recommendation,
                    "confidence": dc_confidence,
                    "value_rating": dnb_away_value,
                    "kelly_pct": round(dnb_away_kelly, 2)
                }
            },
            
            "over15": {
                "odds": odds_over15 or 0,
                "score": round(over15_score, 1),
                "probability": poisson['over15_prob'],
                "recommendation": over15_recommendation,
                "confidence": over_confidence,
                "value_rating": over15_value,
                "kelly_pct": round(over15_kelly, 2),
                "reasoning": over15_reasoning
            },
            "under15": {
                "odds": odds_under15 or 0,
                "score": round(under15_score, 1),
                "probability": poisson['under15_prob'],
                "recommendation": under15_recommendation,
                "confidence": over_confidence,
                "value_rating": under15_value,
                "kelly_pct": round(under15_kelly, 2),
                "reasoning": under15_reasoning
            },
            "over35": {
                "odds": odds_over35 or 0,
                "score": round(over35_score, 1),
                "probability": poisson['over35_prob'],
                "recommendation": over35_recommendation,
                "confidence": over_confidence,
                "value_rating": over35_value,
                "kelly_pct": round(over35_kelly, 2),
                "reasoning": over35_reasoning
            },
            "under35": {
                "odds": odds_under35 or 0,
                "score": round(under35_score, 1),
                "probability": poisson['under35_prob'],
                "recommendation": under35_recommendation,
                "confidence": over_confidence,
                "value_rating": under35_value,
                "kelly_pct": round(under35_kelly, 2),
                "reasoning": under35_reasoning
            },
            "best_market": {
                "type": best_market[0],
                "score": round(best_market[1], 1),
                "recommendation": best_market[2]
            },
            "worst_market": {
                "type": worst_market[0],
                "score": round(worst_market[1], 1),
                "recommendation": worst_market[2]
            },
            "patron": {
                "score": round(patron_score, 1),
                "match_interest": match_interest,
                "data_quality": {
                    "home_stats": home_stats is not None,
                    "away_stats": away_stats is not None,
                    "h2h": h2h is not None
                }
            },
            
            "generated_at": datetime.now().isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/predict-teams")
async def predict_by_teams(
    home_team: str,
    away_team: str,
    odds_btts: float = None,
    odds_over25: float = None
):
    """
    Analyse directe par noms d'√©quipes (sans match_id)
    Utile pour les matchs √† venir
    """
    # G√©n√©rer un match_id temporaire
    match_id = f"direct_{home_team[:3]}_{away_team[:3]}_{datetime.now().strftime('%Y%m%d')}"
    
    # R√©utiliser la logique
    home_stats = get_team_stats(home_team)
    away_stats = get_team_stats(away_team)
    h2h = get_h2h_stats(home_team, away_team)
    
    if not home_stats and not away_stats:
        raise HTTPException(status_code=404, 
                          detail=f"Teams not found: {home_team}, {away_team}")
    
    # Calculer xG
    home_xg = 1.5
    away_xg = 1.2
    
    if home_stats and away_stats:
        home_scored = safe_float(home_stats.get('home_avg_scored'), 1.5)
        away_conceded = safe_float(away_stats.get('away_avg_conceded'), 1.5)
        home_xg = (home_scored + away_conceded) / 2 * 1.15
        
        away_scored = safe_float(away_stats.get('away_avg_scored'), 1.2)
        home_conceded = safe_float(home_stats.get('home_avg_conceded'), 1.2)
        away_xg = (away_scored + home_conceded) / 2 / 1.15
    
    home_xg = max(0.5, min(4.0, home_xg))
    away_xg = max(0.3, min(3.5, away_xg))
    
    poisson = calculate_poisson(home_xg, away_xg)
    
    # BTTS Score
    btts_score = poisson['btts_prob'] * 0.35
    if home_stats and away_stats:
        global_btts = (safe_float(home_stats.get('btts_pct'), 50) + 
                      safe_float(away_stats.get('btts_pct'), 50)) / 2
        btts_score += global_btts * 0.40
    else:
        btts_score += 50 * 0.40
    
    if h2h:
        btts_score += safe_float(h2h.get('btts_pct'), 50) * 0.25
    else:
        btts_score += 50 * 0.25
    
    btts_score = max(0, min(100, btts_score))
    
    # Over Score
    over_score = poisson['over25_prob'] * 0.40
    xg_factor = min(100, max(0, (home_xg + away_xg - 2.5) * 40 + 50))
    over_score += xg_factor * 0.20
    
    if home_stats and away_stats:
        global_over = (safe_float(home_stats.get('over_25_pct'), 50) + 
                      safe_float(away_stats.get('over_25_pct'), 50)) / 2
        over_score += global_over * 0.25
    else:
        over_score += 50 * 0.25
    
    if h2h:
        over_score += safe_float(h2h.get('over_25_pct'), 50) * 0.15
    else:
        over_score += 50 * 0.15
    
    over_score = max(0, min(100, over_score))
    
    return {
        "home_team": home_team,
        "away_team": away_team,
        "poisson": {
            "home_xg": round(home_xg, 2),
            "away_xg": round(away_xg, 2),
            "total_xg": round(home_xg + away_xg, 2),
            "btts_prob": poisson['btts_prob'],
            "over25_prob": poisson['over25_prob'],
            "1x2": poisson['1x2'],
            "most_likely_scores": poisson['most_likely_scores'],
                "btts_no_prob": poisson['btts_no_prob'],
                "under15_prob": poisson['under15_prob'],
                "under25_prob": poisson['under25_prob'],
                "under35_prob": poisson['under35_prob'],
                "double_chance": poisson['double_chance'],
                "draw_no_bet": poisson['draw_no_bet'][:3]
        },
        "btts": {
                "odds": odds_btts or 0,
            "score": round(btts_score, 1),
            "recommendation": get_recommendation(btts_score, 70),
            "value_rating": get_value_rating(btts_score, odds_btts) if odds_btts else "N/A"
        },
        "over25": {
                "odds": odds_over25 or 0,
            "score": round(over_score, 1),
            "recommendation": get_recommendation(over_score, 70),
            "value_rating": get_value_rating(over_score, odds_over25) if odds_over25 else "N/A"
        },
        "data_available": {
            "home_stats": home_stats is not None,
            "away_stats": away_stats is not None,
            "h2h": h2h is not None
        }
    }


@router.get("/top-predictions")
async def get_top_predictions(
    market: str = "all",
    min_score: float = 60,
    limit: int = 10
):
    """
    R√©cup√®re les meilleures pr√©dictions logg√©es
    """
    try:
        conn = psycopg2.connect(**DB_CONFIG)
        cur = conn.cursor(cursor_factory=RealDictCursor)
        
        query = """
            SELECT * FROM market_predictions 
            WHERE predicted_score >= %s
            AND status = 'pending'
        """
        params = [min_score]
        
        if market != "all":
            query += " AND market = %s"
            params.append(market)
        
        query += " ORDER BY predicted_score DESC LIMIT %s"
        params.append(limit)
        
        cur.execute(query, params)
        results = cur.fetchall()
        
        cur.close()
        conn.close()
        
        return {
            "count": len(results),
            "predictions": results
        }
    except Exception as e:
        return {"error": str(e)}


# üß† Endpoint pour analyse LLM enrichie
@router.post("/analyze-llm/{match_id}")
async def analyze_match_with_llm(match_id: str, data: dict):
    """Analyse LLM enrichie par donn√©es locales"""
    import httpx
    import os
    
    openai_key = os.getenv("OPENAI_API_KEY")
    if not openai_key:
        return {"error": "OpenAI API key not configured", "narrative": None}
    
    home_team = data.get("home_team", "√âquipe A")
    away_team = data.get("away_team", "√âquipe B")
    league = data.get("league", "Football")
    xg_home = data.get("xg_home", 0)
    xg_away = data.get("xg_away", 0)
    xg_total = data.get("xg_total", 0)
    markets = data.get("markets", {})
    top3 = data.get("top3", [])
    combos = data.get("combos", [])
    alerts = data.get("alerts", [])
    context = data.get("context", "")
    
    markets_text = "\n".join([f"- {k}: {v.get('score', 0):.0f}% | {v.get('recommendation', 'N/A')} | Value: {v.get('value_rating', 'N/A')} | Kelly: {v.get('kelly_pct', 0):.1f}%" for k, v in markets.items() if v and v.get('score', 0) > 0])
    top3_text = "\n".join([f"  {i+1}. {m.get('name', '')} - {m.get('score', 0):.0f}% : {m.get('reasoning', '')}" for i, m in enumerate(top3)])
    combos_text = "\n".join([f"  - {c.get('name', '')} ({c.get('confidence', 0):.0f}%): {c.get('reasoning', '')}" for c in combos]) if combos else "Aucun combo d√©tect√©"
    alerts_text = "\n".join([f"  - {a}" for a in alerts]) if alerts else "Aucune alerte"
    
    prompt = f"""Tu es un analyste sportif professionnel. Analyse ce match:

MATCH: {home_team} vs {away_team} ({league})
xG: {home_team} {xg_home:.2f} - {away_team} {xg_away:.2f} (Total: {xg_total:.2f})
Contexte: {context}

MARCH√âS (13):
{markets_text}

TOP 3:
{top3_text}

COMBIN√âS:
{combos_text}

ALERTES:
{alerts_text}

G√©n√®re une analyse narrative compl√®te de 300-400 mots. Structure:
1. Contexte du match (profil offensif/d√©fensif)
2. Analyse COMPL√àTE des 13 march√©s (BTTS, Over/Under 1.5/2.5/3.5, Double Chance, DNB) avec focus sur les TOP 3
3. Combin√©s recommand√©s
4. Points de vigilance
5. VALUE BETS: March√©s avec Kelly > 3% = meilleures opportunit√©s
6. VERDICT FINAL: meilleur pari unique + meilleur combo (privil√©gier value bets)

Style direct, professionnel, avec emojis."""

    try:
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                "https://api.openai.com/v1/chat/completions",
                headers={"Authorization": f"Bearer {openai_key}", "Content-Type": "application/json"},
                json={"model": "gpt-4o-mini", "messages": [{"role": "user", "content": prompt}], "max_tokens": 800, "temperature": 0.7}
            )
            if response.status_code == 200:
                result = response.json()
                return {"narrative": result["choices"][0]["message"]["content"], "match_id": match_id}
            else:
                return {"error": f"OpenAI error: {response.status_code}", "narrative": None}
    except Exception as e:
        return {"error": str(e), "narrative": None}
